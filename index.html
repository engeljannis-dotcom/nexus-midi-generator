<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#05050a">
<title>NEXUS GENERATOR v5</title>
<link href="https://fonts.googleapis.com/css2?family=DM+Mono:wght@300;400;500&family=Bebas+Neue&display=swap" rel="stylesheet">
<style>
:root {
  --bg: #05050a;
  --ph: #d4ff00;
  --panel: #0a0a10;
  --border: #1e1e2e;
  --text: #c8c8d8;
  --muted: #404058;
  --red: #ff2d1a;
  --cyan: #00d8cc;
  --amber: #ff9500;
  --purple: #9955ff;
  --blue: #3a7fff;
  --ff-d: 'Bebas Neue', sans-serif;
  --ff-m: 'DM Mono', monospace;
}
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
html, body { width: 100%; height: 100%; overflow: hidden; background: var(--bg); color: var(--text); font-family: var(--ff-m); }

#grain {
  position: fixed; inset: 0; z-index: 9999; pointer-events: none;
  background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)' opacity='0.04'/%3E%3C/svg%3E");
  opacity: 0.18;
}
#scanlines {
  position: fixed; inset: 0; z-index: 9998; pointer-events: none;
  background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.08) 2px, rgba(0,0,0,0.08) 4px);
}

#app {
  position: fixed; inset: 0;
  display: grid;
  grid-template-rows: 44px 1fr auto;
  background: var(--bg);
}

/* HEADER */
#hdr {
  display: flex; align-items: center; justify-content: space-between;
  padding: 0 12px; border-bottom: 1px solid var(--border);
  background: var(--panel); gap: 8px; overflow: hidden;
}
.hdr-left { display: flex; align-items: center; gap: 8px; min-width: 0; }
.hdr-logo { font-family: var(--ff-d); font-size: 18px; color: var(--ph); letter-spacing: 1px; white-space: nowrap; }
.hdr-sep { color: var(--muted); }
#song-title { font-size: 11px; color: var(--text); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 160px; }
#song-sub { font-size: 9px; color: var(--muted); white-space: nowrap; }
.hdr-right { display: flex; align-items: center; gap: 6px; flex-shrink: 0; }
.chip {
  font-size: 9px; padding: 2px 6px; border: 1px solid var(--border);
  background: var(--bg); border-radius: 2px; white-space: nowrap;
  font-family: var(--ff-m); letter-spacing: 0.5px;
}
#chip-key { color: var(--cyan); border-color: var(--cyan); }
#chip-style { color: var(--amber); border-color: var(--amber); }
#chip-live { color: var(--muted); }
#chip-live.live { color: var(--ph); border-color: var(--ph); animation: blink 1s steps(1) infinite; }
@keyframes blink { 50% { opacity: 0.4; } }

/* MAIN */
#main {
  display: grid;
  grid-template-columns: 1fr 280px;
  overflow: hidden;
}
#left-col { display: flex; flex-direction: column; overflow: hidden; border-right: 1px solid var(--border); }
#right-col { display: flex; flex-direction: column; overflow: hidden; }

/* VIDEO */
#video-wrap {
  flex: 1; position: relative; overflow: hidden; background: #000;
  min-height: 0;
}
#vid-canvas { width: 100%; height: 100%; display: block; }
.vid-overlay {
  position: absolute; bottom: 8px; left: 10px; right: 10px;
  display: flex; justify-content: space-between; align-items: flex-end;
  pointer-events: none;
}
#vid-timecode { font-size: 10px; color: rgba(212,255,0,0.6); font-family: var(--ff-m); }
#vid-chord { font-family: var(--ff-d); font-size: 22px; color: rgba(212,255,0,0.5); letter-spacing: 2px; }
#vid-bpm { font-size: 10px; color: rgba(212,255,0,0.6); font-family: var(--ff-m); }

/* SEQUENCER */
#seq-panel {
  height: 160px; background: var(--panel); border-top: 1px solid var(--border);
  padding: 6px 8px; overflow: hidden; flex-shrink: 0;
}
.seq-row {
  display: flex; align-items: center; gap: 4px; height: 22px; margin-bottom: 2px;
}
.seq-label {
  font-size: 8px; width: 26px; flex-shrink: 0; letter-spacing: 0.5px;
  text-transform: uppercase;
}
.seq-steps { display: flex; gap: 2px; flex: 1; }
.s-step {
  flex: 1; height: 18px; border: 1px solid var(--border);
  background: var(--bg); border-radius: 1px; cursor: default;
  transition: background 0.05s;
}
.s-step.on { background: currentColor; opacity: 0.85; }
.s-step.cur { outline: 1px solid var(--ph); outline-offset: 1px; }
.seq-vu { width: 6px; flex-shrink: 0; height: 18px; background: var(--bg); border: 1px solid var(--border); position: relative; overflow: hidden; }
.seq-vu-fill { position: absolute; bottom: 0; left: 0; right: 0; background: var(--ph); height: 0%; transition: height 0.05s; }

.row-kck .seq-label { color: var(--ph); }
.row-kck .s-step.on { color: var(--ph); }
.row-snr .seq-label { color: var(--red); }
.row-snr .s-step.on { color: var(--red); }
.row-clp .seq-label { color: var(--amber); }
.row-clp .s-step.on { color: var(--amber); }
.row-hht .seq-label { color: var(--blue); }
.row-hht .s-step.on { color: var(--blue); }
.row-oht .seq-label { color: var(--cyan); }
.row-oht .s-step.on { color: var(--cyan); }
.row-prc .seq-label { color: var(--purple); }
.row-prc .s-step.on { color: var(--purple); }

/* RIGHT COL */
#spectrum-wrap {
  flex: 1; display: flex; flex-direction: column; min-height: 0; background: #000;
  border-bottom: 1px solid var(--border);
}
#spec-canvas { flex: 1; width: 100%; display: block; min-height: 0; }
#wave-canvas { height: 50px; width: 100%; display: block; flex-shrink: 0; }

#structure-panel {
  padding: 6px 8px; border-bottom: 1px solid var(--border);
  font-size: 9px; color: var(--muted);
}
#structure-panel .s-title { color: var(--ph); font-size: 8px; letter-spacing: 1px; margin-bottom: 4px; }
#section-list { display: flex; gap: 3px; flex-wrap: wrap; }
.sec-chip {
  padding: 2px 5px; border: 1px solid var(--border); border-radius: 1px;
  font-size: 8px; background: var(--bg);
}
.sec-chip.active { border-color: var(--ph); color: var(--ph); }

#chord-row {
  padding: 5px 8px; border-bottom: 1px solid var(--border);
  font-size: 9px;
}
#chord-row .s-title { color: var(--ph); font-size: 8px; letter-spacing: 1px; margin-bottom: 3px; }
#chord-list { display: flex; gap: 3px; }
.chord-chip {
  padding: 2px 5px; border: 1px solid var(--border); border-radius: 1px;
  font-size: 8px; background: var(--bg); color: var(--text);
}
.chord-chip.active { border-color: var(--cyan); color: var(--cyan); }

#mix-panel { padding: 5px 8px; }
#mix-panel .s-title { color: var(--ph); font-size: 8px; letter-spacing: 1px; margin-bottom: 5px; }
.mix-row { display: flex; align-items: center; gap: 6px; margin-bottom: 3px; }
.mix-lbl { font-size: 8px; width: 30px; color: var(--muted); }
.mix-slider {
  flex: 1; height: 14px; -webkit-appearance: none; appearance: none;
  background: var(--border); border-radius: 0; cursor: pointer; outline: none;
}
.mix-slider::-webkit-slider-thumb {
  -webkit-appearance: none; width: 8px; height: 14px;
  background: var(--ph); cursor: pointer; border-radius: 0;
}
.mix-val { font-size: 8px; width: 24px; text-align: right; color: var(--muted); }

/* FOOTER */
#footer {
  background: var(--panel); border-top: 1px solid var(--border);
  display: flex; flex-wrap: wrap; padding: 6px 8px; gap: 6px;
  align-items: center;
}
.footer-row1 { display: contents; }
.footer-row2 { display: contents; }

#gen-btn {
  font-family: var(--ff-d); font-size: 20px; letter-spacing: 2px;
  background: var(--ph); color: #000; border: none; padding: 0 18px;
  height: 44px; cursor: pointer; border-radius: 2px;
  touch-action: manipulation; -webkit-tap-highlight-color: rgba(0,0,0,0);
  -webkit-appearance: none; transition: opacity 0.1s;
  clip-path: none; flex: 0 0 auto;
}
#gen-btn:active { opacity: 0.7; }
#gen-btn.busy { opacity: 0.5; cursor: wait; }

.transport-mini { display: flex; gap: 4px; }
.t-btn {
  font-size: 13px; background: var(--bg); border: 1px solid var(--border);
  color: var(--text); width: 36px; height: 44px; cursor: pointer;
  border-radius: 2px; touch-action: manipulation;
  -webkit-tap-highlight-color: rgba(0,0,0,0); -webkit-appearance: none;
  transition: border-color 0.1s;
}
.t-btn:hover { border-color: var(--ph); }

#progress-wrap {
  flex: 1; height: 6px; background: var(--border); border-radius: 1px;
  overflow: hidden; min-width: 60px;
}
#progress-fill { height: 100%; width: 0%; background: var(--ph); transition: width 0.1s linear; }

#bpm-control { display: flex; align-items: center; gap: 6px; }
#bpm-control label { font-size: 9px; color: var(--muted); letter-spacing: 1px; }
#bpm-display {
  font-family: var(--ff-d); font-size: 18px; color: var(--ph); min-width: 34px; text-align: right;
}
#bpm-slider {
  width: 90px; height: 14px; -webkit-appearance: none; appearance: none;
  background: var(--border); border-radius: 0; cursor: pointer; outline: none;
}
#bpm-slider::-webkit-slider-thumb {
  -webkit-appearance: none; width: 8px; height: 14px;
  background: var(--ph); cursor: pointer; border-radius: 0;
}

#midi-row { display: flex; align-items: center; gap: 6px; margin-left: auto; }
#midi-btn {
  display: flex; align-items: center; gap: 5px; font-size: 9px; letter-spacing: 1px;
  background: var(--bg); border: 1px solid var(--border); color: var(--muted);
  padding: 0 10px; height: 32px; cursor: pointer; border-radius: 2px;
  touch-action: manipulation; -webkit-appearance: none;
  font-family: var(--ff-m);
}
#midi-btn.connected { border-color: var(--cyan); color: var(--cyan); }
#midi-btn.error { border-color: var(--red); color: var(--red); }
.midi-dot { width: 5px; height: 5px; border-radius: 50%; background: currentColor; }
#tempo-toggle {
  font-size: 9px; background: var(--bg); border: 1px solid var(--border);
  color: var(--muted); padding: 0 8px; height: 32px; cursor: pointer; border-radius: 2px;
  touch-action: manipulation; -webkit-appearance: none; font-family: var(--ff-m);
}
#midi-device-name { font-size: 8px; color: var(--muted); white-space: nowrap; max-width: 80px; overflow: hidden; text-overflow: ellipsis; }
#gen-status { font-size: 9px; color: var(--muted); letter-spacing: 1px; }

/* LOADING SCREEN */
#loading {
  position: fixed; inset: 0; z-index: 1000;
  background: rgba(5,5,10,0.96); display: flex; flex-direction: column;
  align-items: center; justify-content: center; gap: 16px;
  opacity: 0; pointer-events: none; transition: opacity 0.2s;
}
#loading.show { opacity: 1; pointer-events: all; }
.ld-title { font-family: var(--ff-d); font-size: 28px; letter-spacing: 6px; color: var(--ph); }
.ld-steps { font-size: 10px; color: var(--muted); height: 14px; }
.ld-bar-wrap { width: 240px; height: 3px; background: var(--border); }
#ld-bar { height: 100%; width: 0%; background: var(--ph); transition: width 0.15s; }

/* RESPONSIVE MOBILE */
@media (max-width: 700px) {
  #right-col { display: none; }
  #main { grid-template-columns: 1fr; }
  #seq-panel { height: 130px; }
  .footer-row1 { display: flex; width: 100%; align-items: center; gap: 6px; }
  .footer-row2 { display: flex; width: 100%; align-items: center; gap: 6px; }
  #gen-btn { flex: 1; }
}
</style>
</head>
<body>
<div id="grain"></div>
<div id="scanlines"></div>

<div id="app">
  <header id="hdr">
    <div class="hdr-left">
      <span class="hdr-logo">NEXUS GEN v5</span>
      <span class="hdr-sep">|</span>
      <div>
        <div id="song-title">— IDLE —</div>
        <div id="song-sub">PRESS GENERATE</div>
      </div>
    </div>
    <div class="hdr-right">
      <div class="chip" id="chip-key">C MIN</div>
      <div class="chip" id="chip-style">LOFI HIP HOP</div>
      <div class="chip" id="chip-live">IDLE</div>
    </div>
  </header>

  <div id="main">
    <div id="left-col">
      <div id="video-wrap">
        <canvas id="vid-canvas"></canvas>
        <div class="vid-overlay">
          <span id="vid-timecode">00:00:00</span>
          <span id="vid-chord"></span>
          <span id="vid-bpm"></span>
        </div>
      </div>
      <div id="seq-panel">
        <div class="seq-row row-kck">
          <span class="seq-label">KCK</span>
          <div class="seq-steps" id="steps-kick"></div>
          <div class="seq-vu"><div class="seq-vu-fill" id="vu-kick"></div></div>
        </div>
        <div class="seq-row row-snr">
          <span class="seq-label">SNR</span>
          <div class="seq-steps" id="steps-snare"></div>
          <div class="seq-vu"><div class="seq-vu-fill" id="vu-snare"></div></div>
        </div>
        <div class="seq-row row-clp">
          <span class="seq-label">CLP</span>
          <div class="seq-steps" id="steps-clap"></div>
          <div class="seq-vu"><div class="seq-vu-fill" id="vu-clap"></div></div>
        </div>
        <div class="seq-row row-hht">
          <span class="seq-label">HHT</span>
          <div class="seq-steps" id="steps-hihat"></div>
          <div class="seq-vu"><div class="seq-vu-fill" id="vu-hihat"></div></div>
        </div>
        <div class="seq-row row-oht">
          <span class="seq-label">OHT</span>
          <div class="seq-steps" id="steps-openhat"></div>
          <div class="seq-vu"><div class="seq-vu-fill" id="vu-openhat"></div></div>
        </div>
        <div class="seq-row row-prc">
          <span class="seq-label">PRC</span>
          <div class="seq-steps" id="steps-perc"></div>
          <div class="seq-vu"><div class="seq-vu-fill" id="vu-perc"></div></div>
        </div>
      </div>
    </div>

    <div id="right-col">
      <div id="spectrum-wrap">
        <canvas id="spec-canvas"></canvas>
        <canvas id="wave-canvas"></canvas>
      </div>
      <div id="structure-panel">
        <div class="s-title">STRUCTURE</div>
        <div id="section-list"></div>
      </div>
      <div id="chord-row">
        <div class="s-title">CHORDS</div>
        <div id="chord-list"></div>
      </div>
      <div id="mix-panel">
        <div class="s-title">MIX</div>
        <div class="mix-row">
          <span class="mix-lbl">DRUM</span>
          <input type="range" class="mix-slider" id="mx-drum" min="0" max="1" step="0.01" value="0.92">
          <span class="mix-val" id="mv-drum">92</span>
        </div>
        <div class="mix-row">
          <span class="mix-lbl">BASS</span>
          <input type="range" class="mix-slider" id="mx-bass" min="0" max="1" step="0.01" value="0.82">
          <span class="mix-val" id="mv-bass">82</span>
        </div>
        <div class="mix-row">
          <span class="mix-lbl">MEL</span>
          <input type="range" class="mix-slider" id="mx-mel" min="0" max="1" step="0.01" value="0.20">
          <span class="mix-val" id="mv-mel">20</span>
        </div>
        <div class="mix-row">
          <span class="mix-lbl">PAD</span>
          <input type="range" class="mix-slider" id="mx-pad" min="0" max="1" step="0.01" value="0.22">
          <span class="mix-val" id="mv-pad">22</span>
        </div>
      </div>
    </div>
  </div>

  <footer id="footer">
    <div class="footer-row1">
      <button id="gen-btn"><span id="gen-txt">GENERATE</span></button>
      <div class="transport-mini">
        <button class="t-btn" id="t-stop">■</button>
        <button class="t-btn" id="t-play">▶</button>
      </div>
      <div id="progress-wrap"><div id="progress-fill"></div></div>
      <span id="gen-status">STOPPED</span>
    </div>
    <div class="footer-row2">
      <div id="bpm-control">
        <label>BPM</label>
        <div id="bpm-display">120</div>
        <input type="range" id="bpm-slider" min="60" max="180" value="120" step="1">
      </div>
      <div id="midi-row">
        <button id="midi-btn"><div class="midi-dot"></div>MIDI</button>
        <button id="tempo-toggle">
          <span class="int-lbl">INT</span>
          <span class="ext-lbl" style="display:none">EXT</span>
        </button>
        <div id="midi-device-name">NO DEVICE</div>
      </div>
    </div>
  </footer>
</div>

<div id="loading">
  <div class="ld-title">GENERATING</div>
  <div id="ld-steps" class="ld-steps"></div>
  <div class="ld-bar-wrap"><div id="ld-bar" class="ld-bar"></div></div>
</div>

<script>
const G = (() => {
  'use strict';

  // ─── VARIABLES ───────────────────────────────────────────────────────────
  let ctx = null, mGain = null, mComp = null;
  let reverbConv = null, revSend = null;
  let delayN = null, delFeed = null, delSend = null;
  let analyser = null, analyserBuf = null;
  let soundCache = new Map();
  let song = null, playing = false, genCount = 0;
  let songTime = 0, vidPhase = 0, lastTs = 0;
  let vidRAF = null, vizRAF = null, seqTimer = null;
  let bpmOverride = null;
  let isGenerating = false;
  let drumBuffers = {};
  // MIDI
  let midiAccess = null, midiOut = null;
  let midiConnected = false, midiClockMode = 'int';
  let midiClockTimer = null;
  const PPQN = 24;
  // Scheduler
  let nextSchedTime = 0, schedStep = 0;
  const LOOKAHEAD = 0.06;
  // Mix
  let mixDrum = 0.92, mixBass = 0.82, mixMel = 0.20, mixPad = 0.22;
  // Song state
  let curSectionIdx = 0, curChordIdx = 0, stepInSection = 0;
  let drumGains = {}, bassGain = null, melGain = null, padGain = null;

  const SR = 44100;

  // ─── PRNG ─────────────────────────────────────────────────────────────────
  function mkRNG(seed) {
    let s = (seed >>> 0) || 1;
    return () => {
      s += 0x6d2b79f5;
      let t = Math.imul(s ^ s>>>15, 1|s);
      t ^= t + Math.imul(t ^ t>>>7, 61|t);
      return ((t ^ t>>>14) >>> 0) / 4294967296;
    };
  }

  // ─── SCALES ───────────────────────────────────────────────────────────────
  const SCALES = {
    'Minor Pent':   { steps:[0,3,5,7,10],       mood:'dark',      tension:0.3 },
    'Nat Minor':    { steps:[0,2,3,5,7,8,10],    mood:'dark',      tension:0.4 },
    'Dorian':       { steps:[0,2,3,5,7,9,10],    mood:'cool',      tension:0.35 },
    'Phrygian':     { steps:[0,1,3,5,7,8,10],    mood:'tense',     tension:0.6 },
    'Blues':        { steps:[0,3,5,6,7,10],       mood:'gritty',    tension:0.5 },
    'Locrian':      { steps:[0,1,3,5,6,8,10],    mood:'dissonant', tension:0.75 },
    'Harmonic Min': { steps:[0,2,3,5,7,8,11],    mood:'dark',      tension:0.55 },
  };
  const SCALE_NAMES = Object.keys(SCALES);

  const NOTE_NAMES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];

  // ─── STYLES ───────────────────────────────────────────────────────────────
  const STYLES = [
    { name:'LOFI HIP HOP', bpm:[72,92],  swing:[45,65], drumVol:0.92, bassVol:0.82, melVol:0.20, padVol:0.22, vibe:'amber' },
    { name:'DARK TECHNO',  bpm:[128,145],swing:[0,10],  drumVol:0.95, bassVol:0.88, melVol:0.14, padVol:0.12, vibe:'cold'  },
    { name:'BOOM BAP',     bpm:[85,100], swing:[50,70], drumVol:0.92, bassVol:0.85, melVol:0.22, padVol:0.18, vibe:'dusty' },
    { name:'MINIMAL TECH', bpm:[120,134],swing:[0,8],   drumVol:0.90, bassVol:0.85, melVol:0.12, padVol:0.10, vibe:'grey'  },
    { name:'JAZZY LOFI',   bpm:[68,88],  swing:[55,75], drumVol:0.85, bassVol:0.78, melVol:0.25, padVol:0.20, vibe:'warm'  },
    { name:'INDUSTRIAL',   bpm:[136,152],swing:[0,15],  drumVol:0.95, bassVol:0.85, melVol:0.12, padVol:0.10, vibe:'rust'  },
  ];

  const VIBE_COLORS = {
    amber: '#ff9500', cold: '#3a7fff', dusty: '#c8a07a',
    grey: '#808090', warm: '#e8b060', rust: '#cc4422',
  };

  // ─── CHORD PROGRESSIONS ───────────────────────────────────────────────────
  const PROGRESSIONS = [
    [0,5,3,6], [0,5,3,4], [0,3,4,5], [0,6,3,7],
    [0,2,5,3], [0,5,6,3], [0,3,6,4], [0,6,4,5],
  ];

  // ─── MATH UTILS ───────────────────────────────────────────────────────────
  function rInt(a, b, R) { return Math.floor(a + R() * (b - a + 1)); }
  function rF(a, b, R) { return a + R() * (b - a); }
  function mtof(midi) { return 440 * Math.pow(2, (midi - 69) / 12); }
  function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }

  // ─── DSP UTILS ────────────────────────────────────────────────────────────
  function wNoise(n) {
    const b = new Float32Array(n);
    for (let i = 0; i < n; i++) b[i] = Math.random() * 2 - 1;
    return b;
  }

  function envExp(n, rate) {
    const b = new Float32Array(n);
    for (let i = 0; i < n; i++) b[i] = Math.exp(-i * rate / SR);
    return b;
  }

  function pitchSweep(n, f0, f1) {
    const b = new Float32Array(n);
    let phase = 0;
    for (let i = 0; i < n; i++) {
      const t = i / n;
      const f = f0 * Math.pow(f1 / f0, t);
      phase += f / SR;
      b[i] = Math.sin(2 * Math.PI * phase);
    }
    return b;
  }

  function biquadLP(input, fc, Q) {
    const w0 = 2 * Math.PI * fc / SR;
    const alpha = Math.sin(w0) / (2 * Q);
    const cosw = Math.cos(w0);
    const b0 = (1 - cosw) / 2, b1 = 1 - cosw, b2 = b0;
    const a0 = 1 + alpha, a1 = -2 * cosw, a2 = 1 - alpha;
    const out = new Float32Array(input.length);
    let x1 = 0, x2 = 0, y1 = 0, y2 = 0;
    for (let i = 0; i < input.length; i++) {
      const x = input[i];
      const y = (b0*x + b1*x1 + b2*x2 - a1*y1 - a2*y2) / a0;
      x2 = x1; x1 = x; y2 = y1; y1 = y;
      out[i] = y;
    }
    return out;
  }

  function biquadHP(input, fc, Q) {
    const w0 = 2 * Math.PI * fc / SR;
    const alpha = Math.sin(w0) / (2 * Q);
    const cosw = Math.cos(w0);
    const b0 = (1 + cosw) / 2, b1 = -(1 + cosw), b2 = b0;
    const a0 = 1 + alpha, a1 = -2 * cosw, a2 = 1 - alpha;
    const out = new Float32Array(input.length);
    let x1 = 0, x2 = 0, y1 = 0, y2 = 0;
    for (let i = 0; i < input.length; i++) {
      const x = input[i];
      const y = (b0*x + b1*x1 + b2*x2 - a1*y1 - a2*y2) / a0;
      x2 = x1; x1 = x; y2 = y1; y1 = y;
      out[i] = y;
    }
    return out;
  }

  function biquadBP(input, fc, Q) {
    const w0 = 2 * Math.PI * fc / SR;
    const alpha = Math.sin(w0) / (2 * Q);
    const cosw = Math.cos(w0);
    const b0 = alpha, b1 = 0, b2 = -alpha;
    const a0 = 1 + alpha, a1 = -2 * cosw, a2 = 1 - alpha;
    const out = new Float32Array(input.length);
    let x1 = 0, x2 = 0, y1 = 0, y2 = 0;
    for (let i = 0; i < input.length; i++) {
      const x = input[i];
      const y = (b0*x + b1*x1 + b2*x2 - a1*y1 - a2*y2) / a0;
      x2 = x1; x1 = x; y2 = y1; y1 = y;
      out[i] = y;
    }
    return out;
  }

  function sat(input, drive) {
    const out = new Float32Array(input.length);
    for (let i = 0; i < input.length; i++) {
      const x = input[i] * drive;
      out[i] = x / (1 + Math.abs(x));
    }
    return out;
  }

  function norm(buf) {
    let peak = 0;
    for (let i = 0; i < buf.length; i++) peak = Math.max(peak, Math.abs(buf[i]));
    if (peak < 1e-6) return buf;
    const scale = 0.92 / peak;
    const out = new Float32Array(buf.length);
    for (let i = 0; i < buf.length; i++) out[i] = buf[i] * scale;
    return out;
  }

  function mixN(...args) {
    let n = 0;
    for (let i = 0; i < args.length; i += 2) n = Math.max(n, args[i].length);
    const out = new Float32Array(n);
    for (let i = 0; i < args.length; i += 2) {
      const buf = args[i], vol = args[i+1];
      for (let j = 0; j < buf.length; j++) out[j] += buf[j] * vol;
    }
    return out;
  }

  function makeBuffer(data) {
    const buf = ctx.createBuffer(1, data.length, SR);
    buf.copyToChannel(data, 0);
    return buf;
  }

  // ─── DRUM SYNTHS ──────────────────────────────────────────────────────────
  // Detect mobile to limit buffer sizes
  const isMobile = /Mobi|Android/i.test(navigator.userAgent) || window.innerWidth < 768;

  function dspKick(tune=1, decay=0.5, punch=0.6, dist=0.2) {
    const n = Math.floor(SR * (isMobile ? 0.7 : 1.1));
    const sub = pitchSweep(n, 120*tune, 28*tune);
    const sEnv = envExp(n, decay*500);
    for(let i=0;i<n;i++) sub[i] *= sEnv[i];
    const sub2 = new Float32Array(n);
    for(let i=0;i<n;i++) sub2[i] = Math.sin(2*Math.PI*50*tune*i/SR)*Math.exp(-i/(SR*0.25));
    const subF = sat(biquadLP(sub, 100+tune*20, 0.9), 1.0+dist*1.8);
    const click = biquadBP(wNoise(n), 2000+punch*1200, 1.5);
    const cEnv = envExp(n, 4);
    for(let i=0;i<n;i++) click[i] *= cEnv[i] * (0.06+punch*0.22);
    const thump = biquadBP(wNoise(n), 200, 2.5);
    const tEnv = envExp(n, 28);
    for(let i=0;i<n;i++) thump[i] *= tEnv[i] * (0.18+punch*0.42);
    return norm(mixN(subF,1.0, sub2,0.7, click,1, thump,1));
  }

  function dspSnare(tune=1) {
    const n = Math.floor(SR * 0.4);
    const tone = new Float32Array(n);
    for(let i=0;i<n;i++) {
      const e = Math.exp(-i/(SR*0.08));
      tone[i] = (Math.sin(2*Math.PI*210*tune*i/SR) + 0.4*Math.sin(2*Math.PI*310*tune*i/SR)) * e;
    }
    const body = biquadBP(wNoise(n), 260, 1.2);
    const bEnv = envExp(n, 700);
    for(let i=0;i<n;i++) body[i] *= bEnv[i];
    const crack = biquadHP(wNoise(n), 5200, 0.7);
    const crEnv = envExp(n, 2500);
    for(let i=0;i<n;i++) crack[i] *= crEnv[i];
    const wire = biquadBP(wNoise(n), 5000, 2.0);
    const wEnv = envExp(n, 1800);
    for(let i=0;i<n;i++) wire[i] *= wEnv[i];
    return norm(mixN(tone,0.5, body,0.6, crack,0.8, wire,0.4));
  }

  function dspHihat(open=false) {
    const dur = open ? 0.35 : 0.06;
    const n = Math.floor(SR * dur);
    const partials = [380,720,1050,1680,2650,4200];
    const metal = new Float32Array(n);
    for(const f of partials) {
      const rate = open ? 1800 : 8000;
      for(let i=0;i<n;i++) metal[i] += Math.sin(2*Math.PI*f*i/SR) * Math.exp(-i*rate/SR);
    }
    const fc = open ? 9000 : 12000;
    const noise = biquadLP(wNoise(n), fc, 0.7);
    const nEnv = envExp(n, open ? 1500 : 5000);
    for(let i=0;i<n;i++) noise[i] *= nEnv[i];
    return norm(mixN(metal,0.6, noise,0.5));
  }

  function dspClap() {
    const n = Math.floor(SR * 0.18);
    const out = new Float32Array(n);
    const offsets = [0, Math.floor(SR*0.006), Math.floor(SR*0.011)];
    for(const off of offsets) {
      const burst = biquadBP(wNoise(n), 1200, 1.0);
      const e = envExp(n - off, 4000);
      for(let i=0;i<n-off;i++) out[i+off] += burst[i] * e[i];
    }
    const room = biquadLP(wNoise(n), 3000, 0.8);
    const rEnv = envExp(n, 600);
    for(let i=0;i<n;i++) room[i] *= rEnv[i];
    return norm(mixN(out,1.0, room,0.3));
  }

  function dspPerc(tune=1) {
    const n = Math.floor(SR * 0.12);
    const out = new Float32Array(n);
    const base = 200 * tune;
    for(let h=1;h<=4;h++) {
      const ratio = 1 + (h-1)*1.7;
      const e = Math.exp(-h * 0.3);
      for(let i=0;i<n;i++) {
        out[i] += Math.sin(2*Math.PI*base*ratio*i/SR) * Math.exp(-i*3000/SR) * e;
      }
    }
    return norm(out);
  }

  function dspBass(midi, durSec) {
    const freq = mtof(midi);
    const maxDur = isMobile ? 1.2 : 2.0;
    const n = Math.floor(SR * Math.min(durSec * 1.1, maxDur));
    const saw = new Float32Array(n);
    // fewer partials on mobile
    const partials = isMobile ? 6 : 12;
    for(let h=1;h<=partials;h++) {
      const amp = 1/h;
      const hf = freq * h;
      for(let i=0;i<n;i++) saw[i] += amp * Math.sin(2*Math.PI*hf*i/SR);
    }
    // sub sine octave
    const sub = new Float32Array(n);
    for(let i=0;i<n;i++) sub[i] = Math.sin(2*Math.PI*freq*0.5*i/SR);
    // detune copy
    const det = new Float32Array(n);
    const dfreq = freq * 1.004;
    for(let i=0;i<n;i++) det[i] = 0.4 * Math.sin(2*Math.PI*dfreq*i/SR);
    // mix + filter + env
    let mix = mixN(saw,0.6, sub,0.7, det,0.3);
    mix = biquadLP(mix, 180, 0.8);
    mix = sat(mix, 1.3);
    // amp envelope
    const atk = Math.floor(SR * 0.005);
    const rel = Math.floor(SR * 0.08);
    const susEnd = n - rel;
    for(let i=0;i<n;i++) {
      let env = 1;
      if(i < atk) env = i / atk;
      else if(i > susEnd) env = Math.max(0, 1 - (i - susEnd)/rel);
      mix[i] *= env;
    }
    return norm(mix);
  }

  function dspPad(midiNotes, durSec) {
    const maxDur = isMobile ? 2.5 : 4.0;
    const n = Math.floor(SR * Math.min(durSec + 0.3, maxDur));
    const out = new Float32Array(n);
    for(const midi of midiNotes) {
      const freq = mtof(midi);
      for(let d=0;d<3;d++) {
        const detune = [1, 1.0025, 0.9975][d];
        for(let i=0;i<n;i++) out[i] += 0.12 * Math.sin(2*Math.PI*freq*detune*i/SR);
      }
      // sub octave
      const subFreq = mtof(midi - 12);
      for(let i=0;i<n;i++) out[i] += 0.07 * Math.sin(2*Math.PI*subFreq*i/SR);
    }
    // slow attack + fade
    const atk = Math.floor(SR * 0.12);
    const rel = Math.floor(SR * 0.25);
    const relStart = n - rel;
    for(let i=0;i<n;i++) {
      let env = 1;
      if(i < atk) env = i / atk;
      else if(i > relStart) env = Math.max(0, 1-(i-relStart)/rel);
      out[i] *= env;
    }
    return biquadLP(norm(out), 2500, 0.7);
  }

  function dspMelody(midi, durSec) {
    const freq = mtof(midi);
    const n = Math.floor(SR * Math.min(durSec * 0.85, 1.2));
    const out = new Float32Array(n);
    // FM synthesis
    const modRatio = 2.01, modDepth = 1.8;
    for(let i=0;i<n;i++) {
      const mod = Math.sin(2*Math.PI*freq*modRatio*i/SR) * modDepth;
      out[i] = Math.sin(2*Math.PI*freq*i/SR + mod);
    }
    // sub octave
    const sub = new Float32Array(n);
    for(let i=0;i<n;i++) sub[i] = 0.3 * Math.sin(2*Math.PI*freq*0.5*i/SR);
    let mix = mixN(out,0.7, sub,1.0);
    mix = biquadLP(mix, 3000, 0.8);
    // slow attack
    const atk = Math.floor(SR * 0.02);
    const rel = Math.floor(SR * 0.06);
    const relStart = n - rel;
    for(let i=0;i<n;i++) {
      let env = 1;
      if(i < atk) env = i / atk;
      else if(i > relStart) env = Math.max(0, 1-(i-relStart)/rel);
      mix[i] *= env;
    }
    return norm(mix);
  }

  // ─── EUCLIDEAN RHYTHM ─────────────────────────────────────────────────────
  function euclidean(steps, pulses) {
    if(pulses === 0) return new Array(steps).fill(0);
    if(pulses >= steps) return new Array(steps).fill(1);
    const pattern = [];
    const counts = [];
    const remainders = [];
    let divisor = steps - pulses;
    remainders.push(pulses);
    let level = 0;
    do {
      counts.push(Math.floor(divisor / remainders[level]));
      remainders.push(divisor % remainders[level]);
      divisor = remainders[level];
      level++;
    } while(remainders[level] > 1);
    counts.push(1);
    function build(lv) {
      if(lv === -1) { pattern.push(0); return; }
      if(lv === -2) { pattern.push(1); return; }
      for(let i=0;i<counts[lv];i++) build(lv-1);
      if(remainders[lv] !== 0) build(lv-2);
    }
    build(level);
    return pattern.slice(0, steps);
  }

  // ─── SONG BUILDER ────────────────────────────────────────────────────────
  function buildSong(seed) {
    const R = mkRNG(seed);
    const styleIdx = Math.floor(R() * STYLES.length);
    const style = STYLES[styleIdx];
    const bpm = bpmOverride !== null ? bpmOverride : rInt(style.bpm[0], style.bpm[1], R);
    const swing = rF(style.swing[0], style.swing[1], R);
    const rootNote = rInt(48, 60, R); // C3-B3
    const scaleName = SCALE_NAMES[Math.floor(R() * SCALE_NAMES.length)];
    const scale = SCALES[scaleName];
    const progTemplate = PROGRESSIONS[Math.floor(R() * PROGRESSIONS.length)];
    const noteInScale = (degree) => {
      const steps = scale.steps;
      const octave = Math.floor(degree / steps.length);
      const idx = degree % steps.length;
      return rootNote + octave * 12 + steps[idx];
    };
    // Build chord list from progression
    const chords = progTemplate.map(deg => {
      const root = noteInScale(deg);
      return [root, root + 4, root + 7]; // basic triad (MIDI)
    });
    // Sections: intro, verse, chorus, verse, chorus, outro
    const SECTION_NAMES = ['INTRO','VERSE','CHORUS','VERSE 2','CHORUS 2','BRIDGE','OUTRO'];
    const secCount = rInt(4, 6, R);
    const sections = [];
    const names = ['INTRO', ...Array.from({length:secCount-2}, (_,i) => i%2===0 ? `VERSE ${Math.floor(i/2)+1}` : 'CHORUS'), 'OUTRO'];
    for(let i=0;i<names.length;i++) {
      const bars = names[i].includes('CHORUS') ? 4 : 2;
      sections.push({ name: names[i], bars, chordIdx: i % chords.length });
    }
    // Drum patterns per section
    const drumKeys = ['kick','snare','clap','hihat','openhat','perc'];
    const drumPats = {};
    for(const key of drumKeys) {
      drumPats[key] = {};
      for(const sec of sections) {
        let pulses = 0;
        if(key==='kick') pulses = sec.name.includes('CHORUS') ? 6 : 4;
        else if(key==='snare') pulses = 4;
        else if(key==='clap') pulses = sec.name.includes('CHORUS') ? 3 : 2;
        else if(key==='hihat') pulses = sec.name.includes('CHORUS') ? 12 : 8;
        else if(key==='openhat') pulses = 2;
        else pulses = Math.floor(R()*3)+1;
        const offset = Math.floor(R()*3);
        const pat = euclidean(16, pulses);
        // rotate
        drumPats[key][sec.name] = [...pat.slice(offset), ...pat.slice(0, offset)];
      }
    }
    // Bass pattern (Markov-like)
    const bassNotes = [];
    const totalBars = sections.reduce((s,sec) => s + sec.bars, 0);
    for(let b=0;b<totalBars;b++) {
      const secBars = sections.reduce((acc,s,i) => {
        if(b >= acc && b < acc+s.bars) return { found: i, off: b-acc };
        return acc + s.bars;
      }, 0);
      const chordMidi = chords[(typeof secBars === 'object' ? secBars.found : 0) % chords.length][0];
      const notes = [];
      for(let step=0;step<16;step++) {
        if(R() < 0.5 || step===0 || step===8) {
          const octave = R() < 0.6 ? 0 : -12;
          notes.push(chordMidi + octave);
        } else {
          const scaleNote = noteInScale(Math.floor(R() * scale.steps.length));
          notes.push(scaleNote - 12 + (R() < 0.4 ? -12 : 0));
        }
      }
      bassNotes.push(notes);
    }
    // Melody pattern
    const melNotes = [];
    for(let b=0;b<totalBars;b++) {
      const notes = [];
      let lastNote = noteInScale(rInt(3,6,R)) + 12;
      for(let step=0;step<16;step++) {
        if(R() < 0.4) {
          notes.push(null);
        } else {
          const delta = Math.round((R()*2-1)*3);
          const stepN = Math.max(0, Math.min(scale.steps.length*2, scale.steps.length + delta));
          lastNote = noteInScale(stepN) + 12;
          notes.push(lastNote);
        }
      }
      melNotes.push(notes);
    }
    return {
      seed, bpm, swing, style, styleIdx, scaleName, scale, rootNote, chords,
      sections, drumPats, bassNotes, melNotes, totalBars,
      drumVolMult: { kick:1.0, snare:0.88, clap:0.75, hihat:0.45, openhat:0.40, perc:0.35 },
    };
  }

  // ─── AUDIO INIT ───────────────────────────────────────────────────────────
  function initAudio() {
    ctx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: SR });
    // Master chain
    mComp = ctx.createDynamicsCompressor();
    mComp.threshold.value = -14; mComp.ratio.value = 5; mComp.attack.value = 0.003; mComp.release.value = 0.1;
    const bassEQ = ctx.createBiquadFilter();
    bassEQ.type = 'lowshelf'; bassEQ.frequency.value = 120; bassEQ.gain.value = 4.5;
    const hiCut = ctx.createBiquadFilter();
    hiCut.type = 'highshelf'; hiCut.frequency.value = 8000; hiCut.gain.value = -3.5;
    const limiter = ctx.createDynamicsCompressor();
    limiter.threshold.value = -1; limiter.ratio.value = 20; limiter.attack.value = 0.001; limiter.release.value = 0.05;
    mGain = ctx.createGain(); mGain.gain.value = 0.78;
    mComp.connect(bassEQ); bassEQ.connect(hiCut); hiCut.connect(limiter);
    limiter.connect(mGain); mGain.connect(ctx.destination);
    // Analyser
    analyser = ctx.createAnalyser(); analyser.fftSize = 512; analyser.smoothingTimeConstant = 0.75;
    mGain.connect(analyser);
    analyserBuf = new Uint8Array(analyser.frequencyBinCount);
    // Per-track gains
    drumGains = {};
    const drumKeys = ['kick','snare','clap','hihat','openhat','perc'];
    for(const k of drumKeys) {
      const g = ctx.createGain(); g.gain.value = 1.0; g.connect(mComp);
      drumGains[k] = g;
    }
    bassGain = ctx.createGain(); bassGain.gain.value = 1.0; bassGain.connect(mComp);
    melGain = ctx.createGain(); melGain.gain.value = 1.0; melGain.connect(mComp);
    padGain = ctx.createGain(); padGain.gain.value = 1.0; padGain.connect(mComp);
  }

  // ─── PRE-RENDER BUFFERS ──────────────────────────────────────────────────
  function loadingStep(txt, pct) {
    const el = document.getElementById('ld-steps');
    const bar = document.getElementById('ld-bar');
    if(el) el.textContent = txt;
    if(bar) bar.style.width = pct + '%';
  }

  // Yield to browser between heavy tasks — longer on mobile
  function yieldToUI(ms) { return new Promise(r => setTimeout(r, ms)); }

  async function renderOne(label, pct, fn) {
    loadingStep(label, pct);
    await yieldToUI(40); // longer pause so browser can repaint & stay responsive
    return fn();
  }

  async function renderBuffers(s) {
    loadingStep('INIT AUDIO ENGINE', 3);
    await yieldToUI(60);

    drumBuffers.kick    = await renderOne('RENDERING KICK…',    10, () => makeBuffer(dspKick(1, 0.5, 0.6, 0.2)));
    drumBuffers.snare   = await renderOne('RENDERING SNARE…',   22, () => makeBuffer(dspSnare(1)));
    drumBuffers.hihat   = await renderOne('RENDERING HIHAT…',   33, () => makeBuffer(dspHihat(false)));
    drumBuffers.openhat = await renderOne('RENDERING OPENHAT…', 40, () => makeBuffer(dspHihat(true)));
    drumBuffers.clap    = await renderOne('RENDERING CLAP…',    48, () => makeBuffer(dspClap()));
    drumBuffers.perc    = await renderOne('RENDERING PERC…',    54, () => makeBuffer(dspPerc(1)));

    loadingStep('RENDERING BASS…', 62);
    await yieldToUI(40);
    // Only render one bass note per unique root (chord root only) — lighter on mobile
    const stepDur = 60 / s.bpm / 4;
    const bassRoots = new Set();
    for(const chord of s.chords) bassRoots.add(chord[0]);
    // Also collect all pattern notes but limit total
    const allBassNotes = new Set(bassRoots);
    for(const bar of s.bassNotes) for(const n of bar) if(n !== null && n !== undefined) allBassNotes.add(n);
    let bi = 0;
    for(const midi of allBassNotes) {
      const key = `bass_${midi}`;
      if(!soundCache.has(key)) {
        soundCache.set(key, makeBuffer(dspBass(midi - 24, stepDur * 2)));
      }
      bi++;
      if(bi % 3 === 0) await yieldToUI(20); // yield every 3 renders
    }

    loadingStep('RENDERING PAD…', 74);
    await yieldToUI(40);
    for(let ci=0;ci<s.chords.length;ci++) {
      const key = `pad_${ci}`;
      const beatDur = 60 / s.bpm;
      const padNotes = s.chords[ci].map(m => m + 12);
      if(!soundCache.has(key)) {
        soundCache.set(key, makeBuffer(dspPad(padNotes, beatDur * 4)));
      }
      await yieldToUI(30);
    }

    loadingStep('RENDERING MELODY…', 84);
    await yieldToUI(40);
    const allMelNotes = new Set();
    for(const bar of s.melNotes) for(const n of bar) if(n !== null) allMelNotes.add(n);
    let mi = 0;
    for(const midi of allMelNotes) {
      const key = `mel_${midi}`;
      if(!soundCache.has(key)) {
        soundCache.set(key, makeBuffer(dspMelody(midi, stepDur * 3)));
      }
      mi++;
      if(mi % 2 === 0) await yieldToUI(20);
    }

    loadingStep('BUILDING SEQUENCER…', 94);
    await yieldToUI(40);
  }

  function sleep(ms) { return yieldToUI(ms); }

  // ─── SEQUENCER / SCHEDULER ────────────────────────────────────────────────
  function getStepInfo(stepIdx) {
    // Map absolute step index to section/bar/step
    const stepsPerBar = 16;
    let totalSteps = 0;
    let barIdx = 0;
    for(let si=0;si<song.sections.length;si++) {
      const sec = song.sections[si];
      const secSteps = sec.bars * stepsPerBar;
      if(stepIdx < totalSteps + secSteps) {
        const localStep = stepIdx - totalSteps;
        const localBar = Math.floor(localStep / stepsPerBar);
        const step = localStep % stepsPerBar;
        return { sectionIdx: si, section: sec, barIdx: barIdx + localBar, step };
      }
      totalSteps += secSteps;
      barIdx += sec.bars;
    }
    return null;
  }

  function getTotalSteps() {
    return song.sections.reduce((s,sec) => s + sec.bars * 16, 0);
  }

  function schedulerTick() {
    if(!song || !playing) return;
    const bpm = bpmOverride !== null ? bpmOverride : song.bpm;
    const stepDur = 60 / bpm / 4;
    const totalSteps = getTotalSteps();

    while(nextSchedTime < ctx.currentTime + LOOKAHEAD) {
      const info = getStepInfo(schedStep % totalSteps);
      if(!info) { schedStep++; nextSchedTime += stepDur; continue; }
      const { sectionIdx, section, barIdx, step } = info;
      const when = nextSchedTime;
      // Swing
      const swingPct = song.swing;
      let swingOffset = 0;
      if(step % 2 === 1) swingOffset = (swingPct / 200) * stepDur;

      const t = when + swingOffset;

      // Drums
      const drumKeys = ['kick','snare','clap','hihat','openhat','perc'];
      for(const k of drumKeys) {
        const pat = song.drumPats[k][section.name];
        if(pat && pat[step]) {
          playDrum(k, t);
          midiDrumStep(k, t);
        }
      }

      // Bass
      if(barIdx < song.bassNotes.length) {
        const note = song.bassNotes[barIdx][step];
        if(note !== null && note !== undefined) {
          playBassNote(note, stepDur * 1.6, t);
        }
      }

      // Melody
      if(barIdx < song.melNotes.length) {
        const note = song.melNotes[barIdx][step];
        if(note !== null && note !== undefined) {
          playMelNote(note, stepDur * 1.6, t);
        }
      }

      // Pad (every 4 steps = 1 beat)
      if(step % 4 === 0) {
        const chordIdx = section.chordIdx % song.chords.length;
        const key = `pad_${chordIdx}`;
        const buf = soundCache.get(key);
        if(buf && padGain) {
          const src = ctx.createBufferSource();
          src.buffer = buf;
          const vol = ctx.createGain();
          vol.gain.value = mixPad * song.style.padVol;
          src.connect(vol); vol.connect(padGain);
          src.start(t);
        }
        curChordIdx = chordIdx;
        updateChordHighlight(chordIdx);
      }

      // Update UI step (schedule via timeout)
      const uiStep = step;
      const secName = section.name;
      const secIdx = sectionIdx;
      const delay = Math.max(0, (t - ctx.currentTime) * 1000);
      const absStep = schedStep % totalSteps;
      const totalS = totalSteps;
      setTimeout(() => {
        updateSeqStep(uiStep, drumKeys.reduce((o,k) => {
          const p = song.drumPats[k][secName]; o[k] = p ? p[uiStep] : 0; return o;
        }, {}));
        updateProgress(absStep / totalS);
        updateSectionHighlight(secIdx);
        updateTimecode();
        const chord = song.chords[curChordIdx];
        const rootName = NOTE_NAMES[chord[0] % 12];
        const el = document.getElementById('vid-chord');
        if(el) el.textContent = rootName + 'm';
        const vidBpm = document.getElementById('vid-bpm');
        if(vidBpm) vidBpm.textContent = bpm + ' BPM';
      }, delay);

      schedStep++;
      nextSchedTime += stepDur;
    }

    // Check end
    const totalDur = getTotalSteps() * (60 / (bpmOverride !== null ? bpmOverride : song.bpm) / 4);
    songTime = ctx.currentTime - (nextSchedTime - getTotalSteps() * 60 / (bpmOverride !== null ? bpmOverride : song.bpm) / 4);
    if(schedStep >= getTotalSteps() && nextSchedTime < ctx.currentTime + 0.5) {
      // Loop
      schedStep = 0;
    }
  }

  function playDrum(key, when) {
    const buf = drumBuffers[key];
    if(!buf || !drumGains[key]) return;
    const src = ctx.createBufferSource();
    src.buffer = buf;
    const vol = ctx.createGain();
    const basevol = song.drumVolMult[key] || 1.0;
    vol.gain.value = mixDrum * song.style.drumVol * basevol;
    src.connect(vol); vol.connect(drumGains[key]);
    src.start(when);
    // VU flash
    const delay = Math.max(0, (when - ctx.currentTime) * 1000);
    setTimeout(() => { vuFlash(key); }, delay);
  }

  function playBassNote(midi, dur, when) {
    const key = `bass_${midi}`;
    const buf = soundCache.get(key);
    if(!buf || !bassGain) return;
    const src = ctx.createBufferSource();
    src.buffer = buf;
    const vol = ctx.createGain();
    vol.gain.value = mixBass * song.style.bassVol;
    src.connect(vol); vol.connect(bassGain);
    src.start(when);
  }

  function playMelNote(midi, dur, when) {
    const key = `mel_${midi}`;
    const buf = soundCache.get(key);
    if(!buf || !melGain) return;
    const src = ctx.createBufferSource();
    src.buffer = buf;
    const vol = ctx.createGain();
    vol.gain.value = mixMel * song.style.melVol;
    src.connect(vol); vol.connect(melGain);
    src.start(when);
    // Harmony
    if(Math.random() < 0.6) {
      const harmInterval = Math.random() < 0.5 ? 4 : 7;
      const harmMidi = midi + harmInterval;
      const hKey = `mel_${harmMidi}`;
      const hBuf = soundCache.get(hKey);
      if(hBuf) {
        const hSrc = ctx.createBufferSource();
        hSrc.buffer = hBuf;
        const hVol = ctx.createGain();
        hVol.gain.value = mixMel * song.style.melVol * 0.28;
        hSrc.connect(hVol); hVol.connect(melGain);
        hSrc.start(when);
      }
    }
  }

  function startScheduler() {
    nextSchedTime = ctx.currentTime + 0.05;
    schedStep = 0;
    seqTimer = setInterval(schedulerTick, 18);
    try { startMidiClock(); } catch(e) {}
  }

  function stopScheduler() {
    clearInterval(seqTimer); seqTimer = null;
    try { stopMidiClock(); } catch(e) {}
  }

  // ─── UI UPDATES ───────────────────────────────────────────────────────────
  function buildSeqUI(s) {
    const drumKeys = ['kick','snare','clap','hihat','openhat','perc'];
    for(const k of drumKeys) {
      const container = document.getElementById(`steps-${k}`);
      if(!container) continue;
      container.innerHTML = '';
      const sec = s.sections[0];
      const pat = s.drumPats[k][sec.name] || [];
      for(let i=0;i<16;i++) {
        const d = document.createElement('div');
        d.className = 's-step' + (pat[i] ? ' on' : '');
        d.dataset.key = k; d.dataset.step = i;
        container.appendChild(d);
      }
    }
  }

  function updateSeqStep(step, drumState) {
    // Clear previous cur
    document.querySelectorAll('.s-step.cur').forEach(e => e.classList.remove('cur'));
    const drumKeys = ['kick','snare','clap','hihat','openhat','perc'];
    for(const k of drumKeys) {
      const container = document.getElementById(`steps-${k}`);
      if(!container) continue;
      const steps = container.querySelectorAll('.s-step');
      if(steps[step]) {
        steps[step].classList.add('cur');
        // update on/off based on current section
        if(song && song.sections[curSectionIdx]) {
          const pat = song.drumPats[k][song.sections[curSectionIdx].name] || [];
          steps.forEach((el, i) => {
            el.classList.toggle('on', !!pat[i]);
          });
        }
      }
    }
  }

  function updateProgress(pct) {
    const el = document.getElementById('progress-fill');
    if(el) el.style.width = (pct * 100) + '%';
  }

  function updateSectionHighlight(secIdx) {
    curSectionIdx = secIdx;
    document.querySelectorAll('.sec-chip').forEach((el, i) => {
      el.classList.toggle('active', i === secIdx);
    });
  }

  function updateChordHighlight(ci) {
    document.querySelectorAll('.chord-chip').forEach((el, i) => {
      el.classList.toggle('active', i === ci);
    });
  }

  function updatePlayBtn(isPlaying) {
    const btn = document.getElementById('t-play');
    if(btn) btn.textContent = isPlaying ? '⏸' : '▶';
  }

  function vuFlash(key) {
    const el = document.getElementById(`vu-${key}`);
    if(!el) return;
    el.style.height = (60 + Math.random()*40) + '%';
    setTimeout(() => { if(el) el.style.height = '0%'; }, 80);
  }

  let tcStart = 0;
  function updateTimecode() {
    const el = document.getElementById('vid-timecode');
    if(!el || !ctx) return;
    const t = ctx.currentTime - tcStart;
    const s = Math.floor(t) % 60;
    const m = Math.floor(t / 60) % 60;
    const ms = Math.floor((t % 1) * 100);
    el.textContent = `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}:${String(ms).padStart(2,'0')}`;
  }

  function buildRightColUI(s) {
    // Sections
    const secList = document.getElementById('section-list');
    if(secList) {
      secList.innerHTML = '';
      s.sections.forEach((sec, i) => {
        const d = document.createElement('div');
        d.className = 'sec-chip'; d.textContent = sec.name;
        secList.appendChild(d);
      });
    }
    // Chords
    const chordList = document.getElementById('chord-list');
    if(chordList) {
      chordList.innerHTML = '';
      s.chords.forEach((chord, i) => {
        const root = NOTE_NAMES[chord[0] % 12];
        const d = document.createElement('div');
        d.className = 'chord-chip'; d.textContent = root + 'm';
        chordList.appendChild(d);
      });
    }
    // Header chips
    const chipKey = document.getElementById('chip-key');
    if(chipKey) chipKey.textContent = NOTE_NAMES[s.rootNote % 12] + ' ' + s.scaleName.toUpperCase();
    const chipStyle = document.getElementById('chip-style');
    if(chipStyle) chipStyle.textContent = s.style.name;
    // Song title
    const titleEl = document.getElementById('song-title');
    if(titleEl) titleEl.textContent = `NEXUS-${String(s.seed).slice(-4).toUpperCase()}`;
    const subEl = document.getElementById('song-sub');
    if(subEl) subEl.textContent = `${s.style.name} • ${s.bpm} BPM • ${s.scaleName.toUpperCase()}`;
  }

  // ─── VIDEO CANVAS ────────────────────────────────────────────────────────
  function startVidRender() {
    if(vidRAF) cancelAnimationFrame(vidRAF);
    const canvas = document.getElementById('vid-canvas');
    if(!canvas) return;
    const vibe = VIBE_COLORS[song ? song.style.vibe : 'amber'] || '#ff9500';

    function frame(ts) {
      vidRAF = requestAnimationFrame(frame);
      const wrap = canvas.parentElement;
      canvas.width = wrap.offsetWidth;
      canvas.height = wrap.offsetHeight;
      const W = canvas.width, H = canvas.height;
      const cx = canvas.getContext('2d');

      // Get audio data
      if(analyser) analyser.getByteFrequencyData(analyserBuf);
      const freq = analyserBuf;
      const fLen = freq ? freq.length : 0;

      // BG
      cx.fillStyle = `${vibe}08`;
      cx.fillRect(0, 0, W, H);

      // Grid
      cx.strokeStyle = `${vibe}18`;
      cx.lineWidth = 0.5;
      const gt = (ts / 8000);
      for(let x=0;x<W;x+=24) {
        cx.beginPath();
        cx.moveTo(x + Math.sin(gt + x*0.05)*2, 0);
        cx.lineTo(x + Math.sin(gt + x*0.05 + 3.14)*2, H);
        cx.stroke();
      }
      for(let y=0;y<H;y+=24) {
        cx.beginPath();
        cx.moveTo(0, y + Math.cos(gt + y*0.05)*2);
        cx.lineTo(W, y + Math.cos(gt + y*0.05 + 3.14)*2);
        cx.stroke();
      }

      if(playing && fLen > 0) {
        // Freq bars
        const bars = 96;
        const bw = W / bars;
        for(let i=0;i<bars;i++) {
          const fi = Math.floor(i * fLen / bars);
          const v = (freq[fi] || 0) / 255;
          const h = v * H * 0.5;
          const hue = 60 + i * 1.5;
          cx.fillStyle = `hsla(${hue},90%,55%,0.8)`;
          cx.fillRect(i * bw, H - h, bw - 1, h);
        }

        // Radial spectrum
        const cx2 = cx, R2 = Math.min(W, H) * 0.25;
        const spokes = 48;
        cx2.save();
        cx2.translate(W/2, H/2);
        for(let i=0;i<spokes;i++) {
          const fi = Math.floor(i * fLen / spokes);
          const v = (freq[fi] || 0) / 255;
          const angle = (i / spokes) * Math.PI * 2;
          const r1 = R2 * 0.3, r2 = R2 * (0.3 + v * 0.7);
          cx2.beginPath();
          cx2.moveTo(Math.cos(angle)*r1, Math.sin(angle)*r1);
          cx2.lineTo(Math.cos(angle)*r2, Math.sin(angle)*r2);
          const hue2 = (i/spokes)*360;
          cx2.strokeStyle = `hsla(${hue2},90%,65%,0.7)`;
          cx2.lineWidth = 1.5;
          cx2.stroke();
        }
        cx2.restore();

        // Waveform
        if(analyser) {
          const waveBuf = new Uint8Array(analyser.fftSize);
          analyser.getByteTimeDomainData(waveBuf);
          cx.beginPath();
          cx.strokeStyle = `${vibe}cc`;
          cx.lineWidth = 1;
          for(let i=0;i<waveBuf.length;i++) {
            const x = (i / waveBuf.length) * W;
            const y = ((waveBuf[i] / 128) - 1) * H * 0.15 + H/2;
            i===0 ? cx.moveTo(x,y) : cx.lineTo(x,y);
          }
          cx.stroke();
          // Mirror
          cx.beginPath();
          cx.strokeStyle = `${vibe}44`;
          for(let i=0;i<waveBuf.length;i++) {
            const x = (i / waveBuf.length) * W;
            const y = -((waveBuf[i] / 128) - 1) * H * 0.1 + H/2;
            i===0 ? cx.moveTo(x,y) : cx.lineTo(x,y);
          }
          cx.stroke();
        }
      }

      // Scanline overlay
      for(let y=0;y<H;y+=4) {
        cx.fillStyle = 'rgba(0,0,0,0.06)';
        cx.fillRect(0, y, W, 2);
      }
    }
    frame(0);
  }

  // ─── VIZ CANVASES (spectrum + wave right col) ─────────────────────────────
  function startVizRender() {
    if(vizRAF) cancelAnimationFrame(vizRAF);
    const specCanvas = document.getElementById('spec-canvas');
    const waveCanvas = document.getElementById('wave-canvas');
    if(!specCanvas || !waveCanvas) return;

    function frame() {
      vizRAF = requestAnimationFrame(frame);
      if(analyser) analyser.getByteFrequencyData(analyserBuf);

      // Spectrum
      const sw = specCanvas.parentElement ? specCanvas.parentElement.offsetWidth : 280;
      const sh = specCanvas.parentElement ? (specCanvas.parentElement.offsetHeight - 50) : 150;
      specCanvas.width = sw; specCanvas.height = Math.max(sh, 60);
      const sc = specCanvas.getContext('2d');
      sc.fillStyle = '#000';
      sc.fillRect(0,0,sw,specCanvas.height);
      if(analyserBuf) {
        const bars = Math.floor(sw / 4);
        for(let i=0;i<bars;i++) {
          const fi = Math.floor(i * analyserBuf.length / bars);
          const v = (analyserBuf[fi] || 0) / 255;
          const h = v * specCanvas.height;
          const hue = 80 + i * 2;
          sc.fillStyle = playing ? `hsl(${hue},90%,50%)` : '#1e1e2e';
          sc.fillRect(i*4, specCanvas.height - h, 3, h);
        }
      }

      // Waveform
      waveCanvas.width = sw; waveCanvas.height = 50;
      const wc = waveCanvas.getContext('2d');
      wc.fillStyle = '#000510';
      wc.fillRect(0,0,sw,50);
      if(analyser && playing) {
        const waveBuf = new Uint8Array(analyser.fftSize);
        analyser.getByteTimeDomainData(waveBuf);
        wc.beginPath();
        wc.strokeStyle = '#d4ff00';
        wc.lineWidth = 1;
        for(let i=0;i<waveBuf.length;i++) {
          const x = (i/waveBuf.length)*sw;
          const y = ((waveBuf[i]/128)-1)*20 + 25;
          i===0 ? wc.moveTo(x,y) : wc.lineTo(x,y);
        }
        wc.stroke();
      } else {
        wc.strokeStyle = '#2a2a3a';
        wc.lineWidth = 1;
        wc.beginPath();
        wc.moveTo(0,25); wc.lineTo(sw,25);
        wc.stroke();
      }
    }
    frame();
  }

  // ─── MIDI ─────────────────────────────────────────────────────────────────
  const MIDI_NOTES = { kick:36, snare:38, clap:39, hihat:42, openhat:46, perc:43 };
  const MIDI_CH = 9;

  function midiSend(bytes) {
    if(!midiOut || !midiConnected) return;
    midiOut.send(bytes);
  }

  async function connectMidi() {
    if(!navigator.requestMIDIAccess) {
      setMidiBtn('error', 'NO MIDI API');
      return;
    }
    try {
      midiAccess = await navigator.requestMIDIAccess({ sysex: false });
      findMidiOut();
      midiAccess.onstatechange = () => { findMidiOut(); };
    } catch(e) {
      setMidiBtn('error', 'MIDI DENIED');
    }
  }

  function findMidiOut() {
    let found = null;
    for(const out of midiAccess.outputs.values()) {
      if(out.name.toLowerCase().includes('tr')) { found = out; break; }
      if(!found) found = out;
    }
    if(found) {
      midiOut = found; midiConnected = true;
      setMidiBtn('connected', found.name);
    } else {
      midiOut = null; midiConnected = false;
      setMidiBtn('default', 'NO DEVICE');
    }
  }

  function setMidiBtn(state, name) {
    const btn = document.getElementById('midi-btn');
    const dev = document.getElementById('midi-device-name');
    if(!btn) return;
    btn.className = '';
    if(state === 'connected') btn.classList.add('connected');
    if(state === 'error') btn.classList.add('error');
    if(dev) dev.textContent = (name || 'NO DEVICE').substring(0, 14);
  }

  function startMidiClock() {
    if(!midiOut || !midiConnected || midiClockMode !== 'int') return;
    stopMidiClock();
    try {
      midiSend([0xFA]);
      const intervalMs = (60000 / (song ? song.bpm : 120)) / PPQN;
      midiClockTimer = setInterval(() => {
        if(midiOut && midiConnected) try { midiSend([0xF8]); } catch(e) {}
      }, intervalMs);
    } catch(e) {}
  }

  function stopMidiClock() {
    if(midiClockTimer) { clearInterval(midiClockTimer); midiClockTimer = null; }
    if(midiOut && midiConnected) try { midiSend([0xFC]); } catch(e) {}
  }

  function midiDrumStep(drumKey, when) {
    if(!midiConnected || !midiOut) return;
    const note = MIDI_NOTES[drumKey];
    if(note === undefined) return;
    const delayMs = Math.max(0, (when - ctx.currentTime) * 1000);
    setTimeout(() => {
      try {
        midiSend([0x90 | MIDI_CH, note, 110]);
        setTimeout(() => { try { midiSend([0x80 | MIDI_CH, note, 0]); } catch(e){} }, 20);
      } catch(e) {}
    }, delayMs);
  }

  // ─── LOADING OVERLAY ─────────────────────────────────────────────────────
  function showLoading(v) {
    const el = document.getElementById('loading');
    if(!el) return;
    if(v) { el.classList.add('show'); }
    else { el.classList.remove('show'); }
  }

  // ─── GENERATE / PLAY / STOP ───────────────────────────────────────────────
  async function generate() {
    if(isGenerating) return;
    isGenerating = true;
    const btn = document.getElementById('gen-btn');
    const txt = document.getElementById('gen-txt');
    showLoading(true);
    try {
      stop();
      soundCache.clear();
      // AudioContext MUST be created/resumed inside user gesture (touchstart/click)
      if(!ctx) {
        try { initAudio(); } catch(e) { console.error('AudioContext init failed:', e); throw e; }
      }
      // Give browser time to process the AudioContext creation before resuming
      await yieldToUI(80);
      if(ctx.state === 'suspended') {
        try { await ctx.resume(); } catch(e) { console.warn('ctx.resume failed:', e); }
      }
      await yieldToUI(40);
      if(btn) btn.classList.add('busy');
      if(txt) txt.textContent = 'RENDERING…';
      genCount++;
      const seed = Date.now() ^ (genCount * 0x9e3779b9);
      song = buildSong(seed);
      await yieldToUI(40);
      await renderBuffers(song);
      loadingStep('BUILDING UI…', 97);
      await yieldToUI(40);
      buildSeqUI(song);
      buildRightColUI(song);
      // Sync BPM slider
      const slider = document.getElementById('bpm-slider');
      const display = document.getElementById('bpm-display');
      if(slider) slider.value = song.bpm;
      if(display) display.textContent = song.bpm;
      bpmOverride = song.bpm;
      loadingStep('READY ✓', 100);
      await yieldToUI(120);
      showLoading(false);
      startPlayback();
    } catch(err) {
      console.error('Generate error:', err);
      // Always hide loading on error
      loadingStep('ERROR — TAP AGAIN', 0);
      await yieldToUI(1200);
      showLoading(false);
    } finally {
      if(btn) btn.classList.remove('busy');
      if(txt) txt.textContent = 'GENERATE';
      isGenerating = false;
    }
  }

  function startPlayback() {
    if(!song || !ctx) return;
    playing = true;
    tcStart = ctx.currentTime;
    startScheduler();
    updatePlayBtn(true);
    const cl = document.getElementById('chip-live');
    if(cl) { cl.textContent = 'LIVE'; cl.classList.add('live'); }
    const gs = document.getElementById('gen-status');
    if(gs) gs.textContent = 'PLAYING';
  }

  function playPause() {
    if(!song) return;
    if(playing) {
      playing = false;
      stopScheduler();
      updatePlayBtn(false);
      const cl = document.getElementById('chip-live');
      if(cl) { cl.textContent = 'PAUSE'; cl.classList.remove('live'); }
      const gs = document.getElementById('gen-status');
      if(gs) gs.textContent = 'PAUSED';
    } else {
      if(!ctx) return;
      if(ctx.state === 'suspended') ctx.resume();
      startPlayback();
    }
  }

  function stop() {
    playing = false;
    try { stopScheduler(); } catch(e) {}
    document.querySelectorAll('.s-step.cur').forEach(e => e.classList.remove('cur'));
    const pf = document.getElementById('progress-fill'); if(pf) pf.style.width = '0%';
    const gs = document.getElementById('gen-status'); if(gs) gs.textContent = 'STOPPED';
    const cl = document.getElementById('chip-live');
    if(cl) { cl.textContent = 'IDLE'; cl.classList.remove('live'); }
    updatePlayBtn(false);
  }

  // ─── BUTTON HELPER ────────────────────────────────────────────────────────
  function addBtn(id, fn) {
    const el = document.getElementById(id);
    if(!el) return;
    let touched = false;
    el.addEventListener('touchstart', e => {
      e.preventDefault(); touched = true; fn();
    }, { passive: false });
    el.addEventListener('click', () => {
      if(touched) { touched = false; return; }
      fn();
    });
  }

  // ─── MIX SLIDERS ─────────────────────────────────────────────────────────
  function initMixSliders() {
    function bind(id, valId, cb) {
      const el = document.getElementById(id);
      const vEl = document.getElementById(valId);
      if(!el) return;
      el.addEventListener('input', () => {
        const v = parseFloat(el.value);
        if(vEl) vEl.textContent = Math.round(v*100);
        cb(v);
      });
    }
    bind('mx-drum', 'mv-drum', v => { mixDrum = v; });
    bind('mx-bass', 'mv-bass', v => { mixBass = v; });
    bind('mx-mel', 'mv-mel', v => { mixMel = v; });
    bind('mx-pad', 'mv-pad', v => { mixPad = v; });
  }

  // ─── BPM SLIDER ──────────────────────────────────────────────────────────
  function initBpmSlider() {
    const slider = document.getElementById('bpm-slider');
    const display = document.getElementById('bpm-display');
    if(!slider) return;
    slider.addEventListener('input', () => {
      const bpm = parseInt(slider.value);
      if(display) display.textContent = bpm;
      bpmOverride = bpm;
      // Update MIDI clock if running
      if(playing && midiConnected && midiClockMode === 'int') {
        try { stopMidiClock(); startMidiClock(); } catch(e) {}
      }
    });
  }

  // ─── TEMPO TOGGLE ────────────────────────────────────────────────────────
  function initTempoToggle() {
    const btn = document.getElementById('tempo-toggle');
    if(!btn) return;
    btn.addEventListener('click', () => {
      midiClockMode = midiClockMode === 'int' ? 'ext' : 'int';
      const intLbl = btn.querySelector('.int-lbl');
      const extLbl = btn.querySelector('.ext-lbl');
      if(intLbl) intLbl.style.display = midiClockMode === 'int' ? '' : 'none';
      if(extLbl) extLbl.style.display = midiClockMode === 'ext' ? '' : 'none';
      if(playing) {
        if(midiClockMode === 'int') try { startMidiClock(); } catch(e) {}
        else try { stopMidiClock(); } catch(e) {}
      }
    });
  }

  // ─── INIT ─────────────────────────────────────────────────────────────────
  function init() {
    addBtn('gen-btn', generate);
    addBtn('t-stop', stop);
    addBtn('t-play', playPause);
    addBtn('midi-btn', connectMidi);
    initMixSliders();
    initBpmSlider();
    initTempoToggle();
    startVidRender();
    startVizRender();
    // Init step divs
    const drumKeys = ['kick','snare','clap','hihat','openhat','perc'];
    for(const k of drumKeys) {
      const container = document.getElementById(`steps-${k}`);
      if(!container) continue;
      container.innerHTML = '';
      for(let i=0;i<16;i++) {
        const d = document.createElement('div');
        d.className = 's-step';
        container.appendChild(d);
      }
    }
  }

  window.addEventListener('load', init);

  return { generate, playPause, stop };
})();
</script>
</body>
</html>
